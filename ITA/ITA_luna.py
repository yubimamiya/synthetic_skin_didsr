# -*- coding: utf-8 -*-
"""ITA_luna.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jL95UkkWX8DfaX48dIN10f4b3ihLJPRT
"""

from skimage import io, color
import numpy as np
import cv2
from PIL import Image
import matplotlib.pyplot as plt
import os
import pandas as pd
import shutil
import seaborn as sns

def calculate_mean_channel_value(channel_array, mask):
    c_mean_temp = np.mean(channel_array[mask==0], axis=0)
    c_std= np.std(channel_array[mask==0], axis=0)
    c_mean = np.mean(channel_array[(channel_array >= c_mean_temp-c_std) & (channel_array <= c_mean_temp+c_std)], axis=0)
    return c_mean

def calculate_ITA(L,b):
    ITA = np.arctan((L-50)/b) * (180/np.pi)
    return ITA

"""Need to create a sample dataset of synthetic images and lesion masks (currently, the images of the masks include the skin)

Need to create a csv spreadsheet with the names of the images and their corresponding masks: may not need mask_id if it can be extrapolated from image_id
"""

data_dir = '/projects01/VICTRE/yubi.mamiya/minimal-diffusion/synth_data/'

# this is a cleaned csv with only the image_id's of images with a good mask
synthetic_metadata = pd.read_csv(data_dir + 'SAM_metadata.csv', delimiter=',')
synthetic_metadata.head()

skin_color=pd.DataFrame(columns=["image_ID", "ITA", "color"])

for image_ID in synthetic_metadata["image_id"]:
    nameimage_path = os.path.join(data_dir + 'ITA_images' +  '/' + image_ID +'.png')
    if os.path.exists(nameimage_path):
        image = cv2.imread(nameimage_path, cv2.IMREAD_COLOR)
    else:
        print("error: image can't be found in data directory")

    mask_path = os.path.join(data_dir + 'ITA_masks' +  '/' + image_ID + '_masks' +'.png')
    # edit to only read in G channel of mask only
    mask = cv2.imread(mask_path, cv2.IMREAD_COLOR)[:,:,1]

    # debugging statements
    # print("mask shape: ", mask.shape)
    # print("image shape: ", image.shape)

    # both have shape (790, 790)
    # image has 3 channels
    # mask has 3 channels but should be black and white
    # white region is lesion and black region is background


    sRGB_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    lab = cv2.cvtColor(image,cv2.COLOR_BGR2LAB)

    # L_channel gets Red channel only where mask is black (skin background)
    L_channel = np.multiply(lab[:,:,0], (mask==0))
    # b_channel gets Blue channel only where mask is black (skin background)
    b_channel = np.multiply(lab[:,:,2], (mask==0))

    L = calculate_mean_channel_value(L_channel, mask)
    b = calculate_mean_channel_value(b_channel, mask)
    ITA = calculate_ITA(L,b)

    skin_color = skin_color._append({"image_ID":nameimage_path.split("/")[-1].split(".")[0], "ITA":ITA }, ignore_index=True)

for i in range(len(skin_color)):
    if skin_color.loc[i,"ITA"] <= 10:
        skin_color.loc[i,"color"] = "dark"
    elif 10 < skin_color.loc[i,"ITA"] <= 19:
        skin_color.loc[i,"color"] = "tan1"
    elif 19 < skin_color.loc[i,"ITA"] <= 28:
        skin_color.loc[i,"color"] = "tan2"
    elif 28 < skin_color.loc[i,"ITA"] <= 34.5:
        skin_color.loc[i,"color"] = "int1"
    elif 34.5 < skin_color.loc[i,"ITA"] <= 41:
        skin_color.loc[i,"color"] = "int2"
    elif 41 < skin_color.loc[i,"ITA"] <= 48:
        skin_color.loc[i,"color"] = "lt1"
    elif 48 < skin_color.loc[i,"ITA"] <= 55:
        skin_color.loc[i,"color"] = "lt2"
    elif skin_color.loc[i,"ITA"] >= 55:
        skin_color.loc[i,"color"] = "very_lt"

# save updated skin_color df
skin_color.to_csv(data_dir + "skin_color.csv", index=False)